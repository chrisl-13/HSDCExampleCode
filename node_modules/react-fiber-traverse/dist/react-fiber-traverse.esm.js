import { Component } from 'react';
import { parse } from 'css-what';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function traverseGenerator(node, _a) {
  function traverseSelf() {
    var controlInput;

    var _a, _b;

    return __generator(this, function (_c) {
      switch (_c.label) {
        case 0:
          if (!!skipSelf) return [3, 2];
          return [4, node];

        case 1:
          controlInput = _c.sent();

          if (controlInput !== undefined) {
            _a = controlInput.skipChild, skipChild = _a === void 0 ? skipChild : _a, _b = controlInput.skipSibling, skipSibling = _b === void 0 ? skipSibling : _b;
          }

          _c.label = 2;

        case 2:
          return [2];
      }
    });
  }

  function traverseChild() {
    var nextNode;
    return __generator(this, function (_a) {
      switch (_a.label) {
        case 0:
          if (!(!skipChild && node.child !== null)) return [3, 2];
          nextNode = node.child;
          return [5, __values(traverseGenerator(nextNode, {
            order: order,
            skipSiblingForStartNode: false,
            skipSelfForStartNode: false
          }))];

        case 1:
          _a.sent();

          _a.label = 2;

        case 2:
          return [2];
      }
    });
  }

  function traverseSibling() {
    var nextNode;
    return __generator(this, function (_a) {
      switch (_a.label) {
        case 0:
          if (!(!skipSibling && node.sibling !== null)) return [3, 2];
          nextNode = node.sibling;
          return [5, __values(traverseGenerator(nextNode, {
            order: order,
            skipSiblingForStartNode: false,
            skipSelfForStartNode: false
          }))];

        case 1:
          _a.sent();

          _a.label = 2;

        case 2:
          return [2];
      }
    });
  }

  var skipChild, skipSibling, skipSelf, traverseMap, orderedGenerators, orderedGenerators_1, orderedGenerators_1_1, eachGen, e_1_1;

  var e_1, _b;

  var _c = _a === void 0 ? {} : _a,
      _d = _c.order,
      order = _d === void 0 ? ["self", "child", "sibling"] : _d,
      _e = _c.skipSiblingForStartNode,
      skipSiblingForStartNode = _e === void 0 ? true : _e,
      _f = _c.skipSelfForStartNode,
      skipSelfForStartNode = _f === void 0 ? false : _f;

  return __generator(this, function (_g) {
    switch (_g.label) {
      case 0:
        skipChild = false, skipSibling = skipSiblingForStartNode, skipSelf = skipSelfForStartNode;
        traverseMap = {
          self: traverseSelf,
          child: traverseChild,
          sibling: traverseSibling
        };
        orderedGenerators = order.map(function (step) {
          return traverseMap[step];
        }).filter(function (tmp) {
          return tmp !== undefined;
        });
        _g.label = 1;

      case 1:
        _g.trys.push([1, 6, 7, 8]);

        orderedGenerators_1 = __values(orderedGenerators), orderedGenerators_1_1 = orderedGenerators_1.next();
        _g.label = 2;

      case 2:
        if (!!orderedGenerators_1_1.done) return [3, 5];
        eachGen = orderedGenerators_1_1.value;
        return [5, __values(eachGen())];

      case 3:
        _g.sent();

        _g.label = 4;

      case 4:
        orderedGenerators_1_1 = orderedGenerators_1.next();
        return [3, 2];

      case 5:
        return [3, 8];

      case 6:
        e_1_1 = _g.sent();
        e_1 = {
          error: e_1_1
        };
        return [3, 8];

      case 7:
        try {
          if (orderedGenerators_1_1 && !orderedGenerators_1_1.done && (_b = orderedGenerators_1["return"])) _b.call(orderedGenerators_1);
        } finally {
          if (e_1) throw e_1.error;
        }

        return [7];

      case 8:
        return [2];
    }
  });
}

function traverse(node, fn, traverseConfig) {
  var e_2, _a;

  var nodeIterator = traverseGenerator(node, traverseConfig);

  try {
    for (var nodeIterator_1 = __values(nodeIterator), nodeIterator_1_1 = nodeIterator_1.next(); !nodeIterator_1_1.done; nodeIterator_1_1 = nodeIterator_1.next()) {
      var tmpNode = nodeIterator_1_1.value;
      fn.call(null, tmpNode);
    }
  } catch (e_2_1) {
    e_2 = {
      error: e_2_1
    };
  } finally {
    try {
      if (nodeIterator_1_1 && !nodeIterator_1_1.done && (_a = nodeIterator_1["return"])) _a.call(nodeIterator_1);
    } finally {
      if (e_2) throw e_2.error;
    }
  }
}

function isNodeHtmlLike(node) {
  return typeof node.type === "string" || node.type === null;
}

function isNodeNotHtmlLike(node) {
  return !isNodeHtmlLike(node);
}

function isNodeFunctionComponent(node) {
  return isNodeNotHtmlLike(node) && node.stateNode === null;
}

function isNodeComponentClass(node) {
  return isNodeNotHtmlLike(node) && node.stateNode instanceof Component;
}

function isConstructorHtmlLike(ctr) {
  if (typeof ctr === "string" || ctr === null) {
    return true;
  }

  return false;
}

function isConstructorComponentClass(ctr) {
  if (isConstructorHtmlLike(ctr)) {
    return false;
  }

  if (ctr.prototype !== undefined && ctr.prototype instanceof Component) {
    return true;
  }

  return false;
}

function isConstructorFunctionComponent(ctr) {
  return typeof ctr === "function" && !isConstructorComponentClass(ctr);
}

function doesElementContainRootFiberNode(element) {
  return element.hasOwnProperty("_reactRootContainer") && element._reactRootContainer.hasOwnProperty("_internalRoot");
}

function getRootFiberNodeFromDOM(startElement) {
  var e_1, _a;

  if (startElement === undefined) {
    startElement = document.body;
  }

  if (doesElementContainRootFiberNode(startElement)) {
    return startElement._reactRootContainer._internalRoot.current;
  }

  var returnFiberNode = null;

  try {
    for (var _b = __values([].slice.call(startElement.children)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var childNode = _c.value;
      returnFiberNode = getRootFiberNodeFromDOM(childNode);

      if (returnFiberNode !== null) {
        return returnFiberNode;
      }
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
    } finally {
      if (e_1) throw e_1.error;
    }
  }

  return returnFiberNode;
}

var utils = /*#__PURE__*/Object.freeze({
    isNodeHtmlLike: isNodeHtmlLike,
    isNodeNotHtmlLike: isNodeNotHtmlLike,
    isNodeFunctionComponent: isNodeFunctionComponent,
    isNodeComponentClass: isNodeComponentClass,
    isConstructorHtmlLike: isConstructorHtmlLike,
    isConstructorComponentClass: isConstructorComponentClass,
    isConstructorFunctionComponent: isConstructorFunctionComponent,
    doesElementContainRootFiberNode: doesElementContainRootFiberNode,
    getRootFiberNodeFromDOM: getRootFiberNodeFromDOM
});

function findNodeByComponentName(node, expectedName, traverseConfig) {
  var e_1, _a;

  if (node === null) {
    return null;
  }

  var nodeIterator = traverseGenerator(node, traverseConfig);

  try {
    for (var nodeIterator_1 = __values(nodeIterator), nodeIterator_1_1 = nodeIterator_1.next(); !nodeIterator_1_1.done; nodeIterator_1_1 = nodeIterator_1.next()) {
      var tmpNode = nodeIterator_1_1.value;

      if (isNodeNotHtmlLike(tmpNode) && tmpNode.type.name === expectedName) {
        return tmpNode;
      }
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (nodeIterator_1_1 && !nodeIterator_1_1.done && (_a = nodeIterator_1["return"])) _a.call(nodeIterator_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }

  return null;
}

function findNodeByComponent(node, expectedClassOrFunction, traverseConfig) {
  var e_3, _a;

  if (node === null) {
    return null;
  }

  var nodeIterator = traverseGenerator(node, traverseConfig);

  try {
    for (var nodeIterator_3 = __values(nodeIterator), nodeIterator_3_1 = nodeIterator_3.next(); !nodeIterator_3_1.done; nodeIterator_3_1 = nodeIterator_3.next()) {
      var tmpNode = nodeIterator_3_1.value;

      if (isNodeNotHtmlLike(tmpNode) && tmpNode.type === expectedClassOrFunction) {
        return tmpNode;
      }
    }
  } catch (e_3_1) {
    e_3 = {
      error: e_3_1
    };
  } finally {
    try {
      if (nodeIterator_3_1 && !nodeIterator_3_1.done && (_a = nodeIterator_3["return"])) _a.call(nodeIterator_3);
    } finally {
      if (e_3) throw e_3.error;
    }
  }

  return null;
}

function findNodeByComponentRef(node, expectedClassInstance, traverseConfig) {
  var e_4, _a;

  if (node === null) {
    return null;
  }

  var nodeIterator = traverseGenerator(node, traverseConfig);

  try {
    for (var nodeIterator_4 = __values(nodeIterator), nodeIterator_4_1 = nodeIterator_4.next(); !nodeIterator_4_1.done; nodeIterator_4_1 = nodeIterator_4.next()) {
      var tmpNode = nodeIterator_4_1.value;

      if (isNodeNotHtmlLike(tmpNode) && tmpNode.stateNode === expectedClassInstance) {
        return tmpNode;
      }
    }
  } catch (e_4_1) {
    e_4 = {
      error: e_4_1
    };
  } finally {
    try {
      if (nodeIterator_4_1 && !nodeIterator_4_1.done && (_a = nodeIterator_4["return"])) _a.call(nodeIterator_4);
    } finally {
      if (e_4) throw e_4.error;
    }
  }

  return null;
}

function matchGenerator(node, match) {
  var matchParsed, selectorsCount, matchParsed_1, matchParsed_1_1, selectorParsed, e_1_1, parsedSelector, currentMatchingNodes, currentMatchingSelectorPartIndex, lastRelationshipSelectorPart, nextMatchingNodes, currentMatchingNodes_1, currentMatchingNodes_1_1, currentNode, currentMatchingSelectorPart, startParams, nextParams, traverseIterator, tmpNode, currentMatchingNodes_2, currentMatchingNodes_2_1, tmpNode, e_2_1;

  var e_1, _a, e_3, _b, _c, e_2, _d;

  return __generator(this, function (_e) {
    switch (_e.label) {
      case 0:
        if (typeof match === "string") {
          matchParsed = parse(match, {
            lowerCaseTags: false,
            lowerCaseAttributeNames: false
          });
        } else {
          matchParsed = match;
        }

        selectorsCount = matchParsed.length;
        if (!(selectorsCount > 1)) return [3, 9];
        _e.label = 1;

      case 1:
        _e.trys.push([1, 6, 7, 8]);

        matchParsed_1 = __values(matchParsed), matchParsed_1_1 = matchParsed_1.next();
        _e.label = 2;

      case 2:
        if (!!matchParsed_1_1.done) return [3, 5];
        selectorParsed = matchParsed_1_1.value;
        return [5, __values(matchGenerator(node, [selectorParsed]))];

      case 3:
        _e.sent();

        _e.label = 4;

      case 4:
        matchParsed_1_1 = matchParsed_1.next();
        return [3, 2];

      case 5:
        return [3, 8];

      case 6:
        e_1_1 = _e.sent();
        e_1 = {
          error: e_1_1
        };
        return [3, 8];

      case 7:
        try {
          if (matchParsed_1_1 && !matchParsed_1_1.done && (_a = matchParsed_1["return"])) _a.call(matchParsed_1);
        } finally {
          if (e_1) throw e_1.error;
        }

        return [7];

      case 8:
        return [2];

      case 9:
        parsedSelector = matchParsed[0];

        if (parsedSelector.length === 0) {
          return [2];
        }

        currentMatchingNodes = [node];
        currentMatchingSelectorPartIndex = 0;
        lastRelationshipSelectorPart = undefined;

        while (currentMatchingSelectorPartIndex < parsedSelector.length) {
          nextMatchingNodes = [];

          try {
            for (currentMatchingNodes_1 = (e_3 = void 0, __values(currentMatchingNodes)), currentMatchingNodes_1_1 = currentMatchingNodes_1.next(); !currentMatchingNodes_1_1.done; currentMatchingNodes_1_1 = currentMatchingNodes_1.next()) {
              currentNode = currentMatchingNodes_1_1.value;
              currentMatchingSelectorPart = parsedSelector[currentMatchingSelectorPartIndex];

              if (["tag"].includes(currentMatchingSelectorPart.type)) {
                startParams = {
                  skipSelfForStartNode: true,
                  skipSiblingForStartNode: true
                };
                nextParams = {};

                if (lastRelationshipSelectorPart === undefined || lastRelationshipSelectorPart.type === "descendant") {
                  nextParams = {
                    skipChild: false,
                    skipSibling: false
                  };
                } else if (lastRelationshipSelectorPart.type === "child") {
                  nextParams = {
                    skipChild: true
                  };
                } else if (lastRelationshipSelectorPart.type === "sibling") {
                  nextParams = {
                    skipChild: true,
                    skipSibling: true
                  };
                  startParams.skipSiblingForStartNode = false;
                }

                traverseIterator = traverseGenerator(currentNode, startParams);

                if (currentMatchingSelectorPart.type == "tag") {
                  tmpNode = void 0;

                  while (!(_c = traverseIterator.next(nextParams), tmpNode = _c.value, _c).done) {
                    if (isNodeNotHtmlLike(tmpNode) && tmpNode.type.name === currentMatchingSelectorPart.name) {
                      nextMatchingNodes.push(tmpNode);
                    }
                  }
                }
              } else if (["descendant", "child"].includes(currentMatchingSelectorPart.type)) {
                lastRelationshipSelectorPart = currentMatchingSelectorPart;
                nextMatchingNodes.push.apply(nextMatchingNodes, __spread(currentMatchingNodes));
              } else {
                lastRelationshipSelectorPart = undefined;
              }
            }
          } catch (e_3_1) {
            e_3 = {
              error: e_3_1
            };
          } finally {
            try {
              if (currentMatchingNodes_1_1 && !currentMatchingNodes_1_1.done && (_b = currentMatchingNodes_1["return"])) _b.call(currentMatchingNodes_1);
            } finally {
              if (e_3) throw e_3.error;
            }
          }

          currentMatchingNodes = nextMatchingNodes;
          currentMatchingSelectorPartIndex += 1;
        }

        _e.label = 10;

      case 10:
        _e.trys.push([10, 15, 16, 17]);

        currentMatchingNodes_2 = __values(currentMatchingNodes), currentMatchingNodes_2_1 = currentMatchingNodes_2.next();
        _e.label = 11;

      case 11:
        if (!!currentMatchingNodes_2_1.done) return [3, 14];
        tmpNode = currentMatchingNodes_2_1.value;
        return [4, tmpNode];

      case 12:
        _e.sent();

        _e.label = 13;

      case 13:
        currentMatchingNodes_2_1 = currentMatchingNodes_2.next();
        return [3, 11];

      case 14:
        return [3, 17];

      case 15:
        e_2_1 = _e.sent();
        e_2 = {
          error: e_2_1
        };
        return [3, 17];

      case 16:
        try {
          if (currentMatchingNodes_2_1 && !currentMatchingNodes_2_1.done && (_d = currentMatchingNodes_2["return"])) _d.call(currentMatchingNodes_2);
        } finally {
          if (e_2) throw e_2.error;
        }

        return [7];

      case 17:
        return [2];
    }
  });
}

function matchAll(node, match) {
  return __spread(matchGenerator(node, match));
}

function matchFirst(node, match) {
  var matchIterator = matchGenerator(node, match);
  var firstResult = matchIterator.next();
  matchIterator["throw"] && matchIterator["throw"](new Error("Cleanup"));

  if (!firstResult.done) {
    return firstResult.value;
  }

  return null;
}

export { utils as Utils, findNodeByComponent, findNodeByComponentName, findNodeByComponentRef, matchAll, matchFirst, matchGenerator, traverse, traverseGenerator };
//# sourceMappingURL=react-fiber-traverse.esm.js.map
